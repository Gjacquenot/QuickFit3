  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
  <html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=windows-1250">
  <title>Data Table Online-Help: Expression parser: Special Functions</title>
  </head>
  <body> 
  $$qf_commondoc_header.start$$  $$qf_commondoc_header.end$$ 
  
  
  
  
  
  <h2>General Special Functions</h2>
  <ul>
    
    
  <li><a name="returnfirst"/><!-- func:returnfirst -->
  <b><tt><!-- template -->returnfirst(x1,x2,x3,...)<!-- /template --></tt> - <i>evaluates all parameters <tt>x1</tt>, <tt>x2</tt>, ... and finally returns the value of the first expression</i>:</b> <br>
  Example: $$example:<code>returnfirst(a=1,a=a+1,a=a+1,a*2)</code> will return <code>1</code>. The variable <tt>a</tt> will be defined and have the value <tt>3&nbsp;<i>[=1+1+1]</i></tt> afterwards$$
  <!-- /func:returnfirst -->  
  </li>

   
    
  <li><a name="returnlast"/><!-- func:returnlast -->
  <b><tt><!-- template -->returnlast(x1,x2,x3,...)<!-- /template --></tt> - <i>evaluates all parameters <tt>x1</tt>, <tt>x2</tt>, ... and finally returns the value of the last expression</i>:</b> <br>
  Example: $$example:<code>returnlast(a=1,a=a+1,a=a+1,a*2)</code> will return <code>6 <i>[=(1+1+1)*2]</i></code>. The variable <tt>a</tt> will be defined and have the value <tt>3&nbsp;<i>[=1+1+1]</i></tt> afterwards$$
  <!-- /func:returnlast -->  
  </li>
   


  </ul>
  
  
  <h2>Function-Like Constructs</h2>
  <ul>
    
  <li><a name="if"/><!-- func:if -->
  <b><tt><!-- template -->if(c, t, f)<!-- /template --></tt> - <i>returns <tt>t</tt>, if <tt>c</tt> is true and <tt>f</tt> else. </i>:</b><br> Only one of the expressions t and f are evaluated, depending on the value of c which is always evaluated
  <!-- /func:if -->  
  </li>
  
  <li><a name="cases"/><!-- func:cases -->
  <b><tt><!-- template -->cases(c1, t1, c2, t2, ..., else)<!-- /template --></tt> - <i>a cases statement, i.e. <code>if(c1, t1, if(c2, t2, if(..., else)))</code> </i>:</b><br>goes through the parameter list and first tests c1, if it is true the function returns t1, else it evaluates c2, if this is true, the function returns t2 ... If no condition evaluates to true, the function returns the value of else
  <!-- /func:cases -->  
  </li>
    
  <li><a name="for"/><!-- func:for -->
  <b><tt><!-- template -->for(VAR, start, delta, end, expression)<!-- /template --></tt>, <tt>for(VAR, start, end, expression)</tt> or <tt>for(VAR, value_vector, expression)</tt> - <i>returns a vector of <tt>expression</tt>, evaluated one time for every value in the vector <tt>value_vector</tt> or every value between <tt>start</tt> and <tt>end</tt> with step <tt>delta</tt> (default: 1). The variable <tt>VAR</tt> holds the according value in each iteration</i>:</b> <br>example: <code>for(i,1,2,5,i^2)</code> will return <code>[1^2, 3^2, 5^2]=[1,9,25]</code>
  <!-- /func:for -->  
  </li>
     
  <li><a name="savefor"/><!-- func:savefor -->
  <b><tt><!-- template -->savefor(VAR, start, delta, end, expression)<!-- /template --></tt>, <tt>savefor(VAR, start, end, expression)</tt> or <tt>savefor(VAR, value_vector, expression)</tt> - <i>returns a vector of <tt>expression</tt>, evaluated one time for every value in the vector <tt>value_vector</tt> or every value between <tt>start</tt> and <tt>end</tt> with step <tt>delta</tt> (default: 1). The variable <tt>VAR</tt> holds the according value in each iteration (save versioN!)</i>:</b> <br>example: <code>savefor(i,1,2,5,i^2)</code> will return <code>[1^2, 3^2, 5^2]=[1,9,25]</code>
  $$note:This is a save version of the command <<t>>fo(---)</tt>, if the expression does not evaluate to a number or number vector, it is simply ignored and no error is caused!$$
  <!-- /func:savefor -->  
  </li>
    
  <li><a name="sum"/><!-- func:sum -->
  <b><tt><!-- template -->sum(VAR, start, delta, end, expression)<!-- /template --></tt>, <tt>sum(VAR, start, end, expression)</tt> or <tt>sum(VAR, value_vector, expression)</tt> - <i>returns the sum of <tt>expression</tt>, evaluated one time for every value in the vector <tt>value_vector</tt> or every value between <tt>start</tt> and <tt>end</tt> with step <tt>delta</tt> (default: 1). The variable <tt>VAR</tt> holds the according value in each iteration</i>:</b> <br>example: <code>sum(i,1,2,5,i^2)</code> will return <code>1^2+3^2+5^2=35</code>
  <!-- /func:sum -->  
  </li>
    
  <li><a name="prod"/><!-- func:prod -->
  <b><tt><!-- template -->prod(VAR, start, delta, end, expression)<!-- /template --></tt>, <tt>prod(VAR, start, end, expression)</tt> or <tt>prod(VAR, value_vector, expression)</tt> - <i>returns the product of <tt>expression</tt>, evaluated one time for every value in the vector <tt>value_vector</tt> or every value between <tt>start</tt> and <tt>end</tt> with step <tt>delta</tt> (default: 1). The variable <tt>VAR</tt> holds the according value in each iteration</i>:</b> <br>example: <code>prod(i,1,2,5,i^2)</code> will return <code>1^2*3^2*5^2=225</code>
  <!-- /func:prod -->  
  </li>

  </ul>

  
  
  
  <h2>Floating Point Number Functions</h2>
  <ul>
    
    
  <li><a name="isnan"/><!-- func:isnan -->
  <b><tt><!-- template -->isnan(x)<!-- /template --></tt> - <i>returns <tt>true</tt> if the given number <tt>x</tt> is not-a-number, if <tt>x</tt> is a vector of numbers, the function will return a vector of booleans.</i>:</b> <br>
  <!-- /func:isnan -->  
  </li>

   
  <li><a name="isinf"/><!-- func:isinf -->
  <b><tt><!-- template -->isinf(x)<!-- /template --></tt> - <i>returns <tt>true</tt> if the given number <tt>x</tt> is infinite, if <tt>x</tt> is a vector of numbers, the function will return a vector of booleans.</i>:</b> <br>
  <!-- /func:isinf -->  
  </li>

   
  <li><a name="isfinite"/><!-- func:isfinite -->
  <b><tt><!-- template -->isfinite(x)<!-- /template --></tt> - <i>returns <tt>true</tt> if the given number <tt>x</tt> is finite, if <tt>x</tt> is a vector of numbers, the function will return a vector of booleans.</i>:</b> <br>
  <!-- /func:isfinite -->  
  </li>

   
  <li><a name="isnumok"/><!-- func:isnumok -->
  <b><tt><!-- template -->isnumok(x)<!-- /template --></tt> - <i>returns <tt>true</tt> if the given number <tt>x</tt> is a valid float (it is finite, not NAN and not infinite), if <tt>x</tt> is a vector of numbers, the function will return a vector of booleans.</i>:</b> <br>
  <!-- /func:isnumok -->  
  </li>

  </ul>

  
  
  
  
  
  <h2>Special Mathematical Functions</h2>
  <ul>
  <li><a name="sigmoid"/><!-- func:sigmoid -->
  <b><tt><!-- template -->sigmoid(x)<!-- /template --></tt> - <i>sigmoidal function </i>:</b><br>
  $$bmath:\mathrm{sigmoid}(x)=\frac{1}{1+\exp(-x)}$$
  The argument <tt>x</tt> may be a vector, then the return value is also a vector of numbers where the function has been applied to each entry of the input vector.
  <!-- /func:sigmoid -->
  </li>
  
  <li><a name="sign"/><!-- func:sign -->
  <b><tt><!-- template -->sign(x)<!-- /template --></tt> - <i>sign function </i>:</b><br>
  $$bmath:\mbox{sign}(x)=\begin{cases}-1 & x<0\\0 & x\equiv 0\\+1 & x>0\end{cases}$$
  The argument <tt>x</tt> may be a vector, then the return value is also a vector of numbers where the function has been applied to each entry of the input vector.
  <!-- /func:sign -->
  </li>
  
  <li><a name="theta"/><!-- func:theta -->
  <b><tt><!-- template -->theta(x)<!-- /template --></tt> - <i>theta step function </i>:</b><br>
  $$bmath:\Theta(x)=\begin{cases}-1 & x<0\\0 & x\equiv 0\\+1 & x>0\end{cases}$$
  The argument <tt>x</tt> may be a vector, then the return value is also a vector of numbers where the function has been applied to each entry of the input vector.
  <!-- /func:theta -->
  </li>
  
  <li><a name="tanc"/><!-- func:tanc -->
  <b><tt><!-- template -->tanc(x)<!-- /template --></tt> - <i>tanc function </i>:</b><br>
  $$bmath:\mbox{tanc}(x)=\begin{cases}1 & x\equiv0\\\frac{\tan(x)}{x}&\mathrm{elsewhere}\end{cases}$$
  The argument <tt>x</tt> may be a vector, then the return value is also a vector of numbers where the function has been applied to each entry of the input vector.
  <!-- /func:tanc -->
  </li>
  
  
  <li><a name="slit"/><!-- func:slit -->
  <b><tt><!-- template -->slit(x,a)<!-- /template --></tt> - <i>slit function (two step function) </i>:</b><br>
  $$bmath:\mbox{slit}(x,a)=\begin{cases}1 & -a/2 \geq x\geq a/2 \\0 & \text{elsewhere}\end{cases}$$
  The argument <tt>x</tt> may be a vector, then the return value is also a vector of numbers where the function has been applied to each entry of the input vector.
  <!-- /func:slit -->
  </li>
  
  
  <li><a name="sinc"/><!-- func:sinc -->
  <b><tt><!-- template -->sinc(x)<!-- /template --></tt> - <i>sinc function </i>:</b><br>
  $$bmath:\mbox{sinc}(x)=\begin{cases}1 & x\equiv0\\\frac{\sin(x)}{x}&\mathrm{elsewhere}\end{cases}$$
  The argument <tt>x</tt> may be a vector, then the return value is also a vector of numbers where the function has been applied to each entry of the input vector.
  <!-- /func:sinc -->
  </li>
  
  <li><a name="erf"/><!-- func:erf -->
  <b><tt><!-- template -->erf(x)<!-- /template --></tt> - <i>error function </i>:</b><br>
  $$bmath:\operatorname{erf}(x) = \frac{2}{\sqrt{\pi}} \int_0^x e^{-\tau^2}\,\mathrm{d}\tau$$
  The argument <tt>x</tt> may be a vector, then the return value is also a vector of numbers where the function has been applied to each entry of the input vector.
  <!-- /func:erf -->
  </li>
  
  <li><a name="erfc"/><!-- func:erfc -->
  <b><tt><!-- template -->erfc(x)<!-- /template --></tt> - <i>erfc function </i>:</b><br>
  $$bmath:\operatorname{erfc}(x) = 1 - \operatorname{erf}(x) = \frac{2}{\sqrt{\pi}} \int_x^\infty e^{-\tau^2}\,\mathrm{d}\tau.$$
  The argument <tt>x</tt> may be a vector, then the return value is also a vector of numbers where the function has been applied to each entry of the input vector.
  <!-- /func:erfc -->
  </li>
  
  <li><a name="lgamma"/><!-- func:lgamma -->
  <b><tt><!-- template -->lgamma(x)<!-- /template --></tt> - <i>logarithmic gamma function </i>:</b><br>
  $$bmath:\ln\left(\Gamma(x)\right) = \ln\left[\int_0^\infty t^{x-1} \mathrm{e}^{-t} \mathrm{d}t\right]$$
  The argument <tt>x</tt> may be a vector, then the return value is also a vector of numbers where the function has been applied to each entry of the input vector.
  <!-- /func:lgamma -->
  </li>
  
  <li><a name="tgamma"/><!-- func:tgamma -->
  <b><tt><!-- template -->sinc(x)<!-- /template --></tt> - <i>gamma function </i>:</b><br>
  $$bmath:\Gamma(x) = \int_0^\infty t^{x-1} \mathrm{e}^{-t} \mathrm{d}t$$
  The argument <tt>x</tt> may be a vector, then the return value is also a vector of numbers where the function has been applied to each entry of the input vector.
  <!-- /func:tgamma -->
  </li>
  
  <li><a name="j0"/><!-- func:j0 -->
  <b><tt><!-- template -->j0(x)<!-- /template --></tt> - <i>Bessel functions of the first kind </i>:</b><br>
  The argument <tt>x</tt> may be a vector, then the return value is also a vector of numbers where the function has been applied to each entry of the input vector.
  <!-- /func:j0 -->
  </li>
  
  <li><a name="j1"/><!-- func:j1 -->
  <b><tt><!-- template -->j1(x)<!-- /template --></tt> - <i>Bessel functions of the first kind </i>:</b><br>
  The argument <tt>x</tt> may be a vector, then the return value is also a vector of numbers where the function has been applied to each entry of the input vector.
  <!-- /func:j1 -->
  </li>
  
  <li><a name="jn"/><!-- func:jn -->
  <b><tt><!-- template -->jn(n, x)<!-- /template --></tt> - <i>Bessel functions of the first kind </i>:</b><br>
  The argument <tt>x</tt> may be a vector, then the return value is also a vector of numbers where the function has been applied to each entry of the input vector.
  <!-- /func:jn -->
  </li>
  
  <li><a name="y0"/><!-- func:y0 -->
  <b><tt><!-- template -->y0(x)<!-- /template --></tt> - <i>Bessel functions of the second kind </i>:</b><br>
  The argument <tt>x</tt> may be a vector, then the return value is also a vector of numbers where the function has been applied to each entry of the input vector.
  <!-- /func:y0 -->
  </li>
  
  <li><a name="y1"/><!-- func:y1 -->
  <b><tt><!-- template -->y1(x)<!-- /template --></tt> - <i>Bessel functions of the second kind </i>:</b><br>
  The argument <tt>x</tt> may be a vector, then the return value is also a vector of numbers where the function has been applied to each entry of the input vector.
  <!-- /func:y1 -->
  </li>
  
  <li><a name="yn"/><!-- func:yn -->
  <b><tt><!-- template -->yn(n, x)<!-- /template --></tt> - <i>Bessel functions of the second kind </i>:</b><br>
  The argument <tt>x</tt> may be a vector, then the return value is also a vector of numbers where the function has been applied to each entry of the input vector.
  <!-- /func:yn -->
  </li>


  <li><a name="min"/><!-- func:min -->
  <b><tt><!-- template -->min(x,y)<!-- /template --></tt> - <i>returns the smaller of the two arguments </i>:</b><br>
  <!-- /func:min -->
  </li>
  
  <li><a name="max"/><!-- func:max -->
  <b><tt><!-- template -->max(x,y)<!-- /template --></tt> - <i>returns the larger of the two arguments </i>:</b><br>
  <!-- /func:max -->
  </li>
  
  <li><a name="fmod"/><!-- func:fmod -->
  <b><tt><!-- template -->fmod(x,y)<!-- /template --></tt> - <i>returns the reminder after division x/y division </i>:</b><br>
  The arguments <tt>x</tt> and <tt>y</tt> may be vectors, then the return value is also a vector of numbers where the function has been applied to each pair of entries of the input vectors.
  <!-- /func:fmod -->
  </li>


  </ul>
  
  </body>
  </html>
  