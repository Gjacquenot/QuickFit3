  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
  <html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=windows-1250">
  <title>Expression parser: Vector Manipulation Functions</title>
  </head>
  <body> 
  $$qf_commondoc_header.start$$  $$qf_commondoc_header.end$$ 
  
  <h2>Vector Creation</h2>
  $$funcref_start$$<a name="zeros"/><!-- func:zeros -->
  <b><tt><!-- template -->zeros(N)<!-- /template --></tt> - <i>creates a number-vector containing <tt>N</tt> elements, which are all 0</i>:</b>
$$funcref_description$$
  <!-- /func:zeros -->  
$$funcref_end$$

  $$funcref_start$$<a name="ones"/><!-- func:ones -->
  <b><tt><!-- template -->ones(N)<!-- /template --></tt> - <i>creates a number-vector containing <tt>N</tt> elements, which are all 1</i>:</b>
$$funcref_description$$
  <!-- /func:ones -->  
$$funcref_end$$

  $$funcref_start$$<a name="vector"/><!-- func:vector -->
  <b><tt><!-- template -->vector(N, v)<!-- /template --></tt> - <i>creates a vector containing <tt>N</tt> elements, which are all <tt>v</tt>. </i>:</b>
$$funcref_description$$
  If <tt>v</tt> is a vector, the output is a vector of <tt>N*length(v)</tt> elements, which contains <tt>N</tt> repeats of the entries in <tt>v</tt>.
  <!-- /func:vector -->  
$$funcref_end$$

  $$funcref_start$$<a name="linspace"/><!-- func:linspace -->
  <b><tt><!-- template -->linspace(x0, x1)<!-- /template --></tt> / <tt><!-- template -->linspace(x0, x1, N)<!-- /template --></tt> - <i>creates a number-vector containing <tt>N</tt> (default: 100) elements, which contains linearly spaced numbers between <tt>x0</tt> and <tt>x1</tt> (inclusive)</i>:</b>
$$funcref_description$$
  <!-- /func:linspace -->  
$$funcref_end$$

  $$funcref_start$$<a name="logspace"/><!-- func:logspace -->
  <b><tt><!-- template -->logspace(a, b)<!-- /template --></tt> / <tt><!-- template -->logspace(a, b, N)<!-- /template --></tt> - <i>creates a number-vector containing <tt>N</tt> (default: 50) elements, which contains logarithmically spaced numbers between 10<sup><tt>a</tt></sup> and 10<sup><tt>b</tt></sup> (inclusive)</i>:</b>
$$funcref_description$$
  <!-- /func:logspace -->  
$$funcref_end$$


  $$funcref_start$$<a name="meshgrid2d_x"/><!-- func:meshgrid2d_x -->
  <b><tt><!-- template -->meshgrid2d_x(X, Y)<!-- /template --></tt> - <i>creates a number-vector containing <tt>length(X)*length(Y)</tt> elements (interpretable as a 2D row-major matrix), which contains the x-ccordinate from a <tt>length(X)*length(Y)</tt> matrix with axes <tt>X</tt> and <tt>Y</tt></i>:</b>
$$funcref_description$$
The vecors <tt>X</tt> and <tt>Y</tt> give x- and y-ranges of coordinates of a 2D matrix with <tt>length(X)*length(Y)</tt> entries:
<pre>(x,y):
+----------+----------+----------+----------+-------------+
| (0,0)    | (1,0)    | (2,0)    | ........ | (Nx-1,0)    |
+----------+----------+----------+----------+-------------+
| (0,1)    | (1,1)    | (2,1)    | ........ | (Nx-1,1)    |
+----------+----------+----------+----------+-------------+
| ........ | ........ | ........ | ........ | ........... |
+----------+----------+----------+----------+-------------+
| (0,Ny-1) | (1,Ny-1) | (2,Ny-1) | ........ | (Nx-1,Ny-1) |
+----------+----------+----------+----------+-------------+
</pre>
The matrix is oriented in row-major format. This function returns the x-coordinates for each entry as a row-major list (from a matrix), i.e.:
<pre>result:
+----------+----------+----------+----------+-------------+
| X[0]     | X[1]     | X[2]     | ........ | X[Nx-1]     |
+----------+----------+----------+----------+-------------+
| X[0]     | X[1]     | X[2]     | ........ | X[Nx-1]     |
+----------+----------+----------+----------+-------------+
| ........ | ........ | ........ | ........ | ........... |
+----------+----------+----------+----------+-------------+
| X[0]     | X[1]     | X[2]     | ........ | X[Nx-1]     |
+----------+----------+----------+----------+-------------+
</pre>

  <!-- /func:meshgrid2d_x -->  
$$funcref_end$$


  $$funcref_start$$<a name="meshgrid2d_y"/><!-- func:meshgrid2d_y -->
  <b><tt><!-- template -->meshgrid2d_y(X, Y)<!-- /template --></tt> - <i>creates a number-vector containing <tt>length(X)*length(Y)</tt> elements (interpretable as a 2D row-major matrix), which contains the y-ccordinate from a <tt>length(X)*length(Y)</tt> matrix with axes <tt>X</tt> and <tt>Y</tt></i>:</b>
$$funcref_description$$
The vecors <tt>X</tt> and <tt>Y</tt> give x- and y-ranges of coordinates of a 2D matrix with <tt>length(X)*length(Y)</tt> entries:
<pre>(x,y):
+----------+----------+----------+----------+-------------+
| (0,0)    | (1,0)    | (2,0)    | ........ | (Nx-1,0)    |
+----------+----------+----------+----------+-------------+
| (0,1)    | (1,1)    | (2,1)    | ........ | (Nx-1,1)    |
+----------+----------+----------+----------+-------------+
| ........ | ........ | ........ | ........ | ........... |
+----------+----------+----------+----------+-------------+
| (0,Ny-1) | (1,Ny-1) | (2,Ny-1) | ........ | (Nx-1,Ny-1) |
+----------+----------+----------+----------+-------------+
</pre>
The matrix is oriented in row-major format. This function returns the x-coordinates for each entry as a row-major list (from a matrix), i.e.:
<pre>result:<br>
+----------+----------+----------+----------+-------------+
| Y[0]     | Y[0]     | Y[0]     | ........ | Y[0]        |
+----------+----------+----------+----------+-------------+
| Y[1]     | Y[1]     | Y[1]     | ........ | Y[1]        |
+----------+----------+----------+----------+-------------+
| ........ | ........ | ........ | ........ | ........... |
+----------+----------+----------+----------+-------------+
| Y[Ny-1]  | Y[Ny-1]  | Y[Ny-1]  | ........ | Y[Ny-1]     |
+----------+----------+----------+----------+-------------+
</pre>

  <!-- /func:meshgrid2d_y -->  
$$funcref_end$$


  
  <h2>Sorting &amp; Reordering</h2>
  

  $$funcref_start$$<a name="sort"/><!-- func:sort -->
  <b><tt><!-- template -->sort(x)<!-- /template --></tt> - <i>sorts the vector <tt>x</tt> in ascending order</i>:</b>
$$funcref_description$$
  <!-- /func:sort -->  
$$funcref_end$$
  
  $$funcref_start$$<a name="dsort"/><!-- func:dsort -->
  <b><tt><!-- template -->dsort(x)<!-- /template --></tt> - <i>sorts the vector <tt>x</tt> in descending order </i>:</b>
$$funcref_description$$
  <!-- /func:dsort -->  
$$funcref_end$$
 
  $$funcref_start$$<a name="shuffle"/><!-- func:shuffle -->
  <b><tt><!-- template -->shuffle(x)<!-- /template --></tt> - <i>shuffle the vector <tt>x</tt> randomly </i>:</b>
$$funcref_description$$
  <!-- /func:shuffle -->  
$$funcref_end$$
  
  $$funcref_start$$<a name="reverse"/><!-- func:reverse -->
  <b><tt><!-- template -->reverse(x)<!-- /template --></tt> - <i>reverse the vector <tt>x</tt> </i>:</b>
$$funcref_description$$
  example: <tt>[1,2,3] -> [3,2,1]</tt>
  <!-- /func:reverse -->  
$$funcref_end$$







<h2>Vector Concatenation</h2>
  
  $$funcref_start$$<a name="concat"/><!-- func:concat -->
  <b><tt><!-- template -->concat(x1, x2, ...)<!-- /template --></tt> - <i>concatenate the parameter vectors <tt>x1, x2, ...</tt> </i>:</b>
$$funcref_description$$
  example: <tt>concat([1,2,3], [4,5,6]) -> [1,2,3,4,5,6]</tt>
  <!-- /func:concat -->  
$$funcref_end$$
  
  
  
  
  
  
  
<h2>Vector Filtering</h2>
  $$funcref_start$$<a name="removeall"/><!-- func:removeall -->
  <b><tt><!-- template -->removeall(x, val)<!-- /template --></tt> - <i>remove all occurenced of value <tt>val</tt> from vector <tt>x</tt> </i>:</b>
$$funcref_description$$
  <!-- /func:removeall -->  
$$funcref_end$$

  
  $$funcref_start$$<a name="filterfinite"/><!-- func:filterfinite -->
  <b><tt><!-- template -->filterfinite(x)<!-- /template --></tt> - <i>remove all infinte/nan numbers from number vector <tt>x</tt> </i>:</b>
$$funcref_description$$
  <!-- /func:filterfinite -->  
$$funcref_end$$
 
  $$funcref_start$$<a name="filternumok"/><!-- func:filternumok -->
  <b><tt><!-- template -->filternumok(x)<!-- /template --></tt> - <i>remove all infinte/nan numbers from number vector <tt>x</tt> </i>:</b>
$$funcref_description$$
  <!-- /func:filternumok -->  
$$funcref_end$$
 
  $$funcref_start$$<a name="remove"/><!-- func:remove -->
  <b><tt><!-- template -->remove(x, index)<!-- /template --></tt> - <i>remove the elements indexed by <tt>index</tt> from vector <tt>x</tt> </i>:</b>
$$funcref_description$$
  <!-- /func:remove -->  
$$funcref_end$$
  

  $$funcref_start$$<a name="unique"/><!-- func:unique -->
  <b><tt><!-- template -->unique(x)<!-- /template --></tt> - <i>returns a list containing all elements in <tt>x</tt>, if any value appears more than once in <tt>x</tt> it is returned only once. The order is the order in the initial data vector <tt>x</tt>.</b>
$$funcref_description$$
  Example:<br><blockquote><tt>
  x=[1,3,2,1,2,3,3,2,1];
  unique[x] -> [1,3,2]
  </tt></blockquote>
  <!-- /func:unique-->  
$$funcref_end$$


  
  
  $$funcref_start$$<a name="replace"/><!-- func:replace -->
  <b><tt><!-- template -->replace(x, old_value, new_value)<!-- /template --></tt> - <i>replace all occurences of <tt>old_value</tt> in the vector or string <tt>x</tt> by <tt>new_value</tt> </i>:</b>
$$funcref_description$$
  <!-- /func:replace -->  
$$funcref_end$$
  
  
  
  $$funcref_start$$<a name="multireplace"/><!-- func:multireplace -->
  <b><tt><!-- template -->multireplace(x, old_value1, new_value1, old_value2, new_value2, ...)<!-- /template --></tt> - <i>multiple replaces in one instruction, i.e. replaces all occurences of <tt>old_value<i>N</i></tt> in the vector or string <tt>x</tt> by <tt>new_value<i>N</i></tt> </i> for all given pairs <tt>old_value<i>N</i></tt>/<tt>new_value<i>N</i></tt>:</b>
$$funcref_description$$
$$note:This is like a nested <tt>replace()</tt>, i.e. <tt>multireplace(x, old_value1, new_value1, old_value2, new_value2) = replace(replace(x, old_value1, new_value1), old_value2, new_value2)</tt>$$
  <!-- /func:multireplace -->  
$$funcref_end$$
  
  
  
  
  
<h2>Test-Operations &amp; Search (contains, find, ...)</h2>
  
$$funcref_start$$<a name="contains"/><!-- func:contains -->
  <b><tt><!-- template -->contains(x, v)<!-- /template --></tt> - <i>returns <tt>true</tt> if the element <tt>v</tt> is contained in the vector <tt>x</tt>.  If both elements are string, it returns true, if the substring <tt>v</tt> appears in <tt>x</tt>. </i>:</b>
$$funcref_description$$
  $$note:For strings, this function does a case-sensitive match!$$
  <!-- /func:contains -->  
$$funcref_end$$
  
$$funcref_start$$<a name="contains_caseinsensitive"/><!-- func:contains_caseinsensitive -->
  <b><tt><!-- template -->contains_caseinsensitive(x, v)<!-- /template --></tt> - <i>returns <tt>true</tt> if the element <tt>v</tt> is contained in the vector <tt>x</tt>.  If both elements are string, it returns true, if the substring <tt>v</tt> appears in <tt>x</tt>. </i>:</b>
$$funcref_description$$
  $$note:For strings, this function does a case-insensitive match!$$
  <!-- /func:contains_caseinsensitive -->  
$$funcref_end$$
  
  
  
  
  $$funcref_start$$<a name="find"/><!-- func:find -->
  <b><tt><!-- template -->find(x, v)<!-- /template -->, find(x)</tt> - <i>returns a list with the array indices of all occurences of <tt>v</tt> in the vector <tt>x</tt>. If <tt>v</tt> is omitted, the functions expects a boolean vector as <tt>x</tt> and finds all occurences of <tt>true</tt> </i>:</b>
$$funcref_description$$
  This function can be used to select items from an array with a logic expression, e.g. <tt>find(x==4)</tt> will return the index list of all items in x that have the value 4. The result can be used in an array access, i.e. <tt>x[find(x>4)]</tt> will return a vector containing only those elements in x where the value is larger than 4. $$see:<a href="#select">select()</a>, <a href="#findfirst">findfirst()</a>$$
  <!-- /func:find -->  
$$funcref_end$$
  

  $$funcref_start$$<a name="findfirst"/><!-- func:findfirst -->
  <b><tt><!-- template -->findfirst(x, v)<!-- /template -->, findfirst(x)</tt> - <i>returns the first array index of an occurences of <tt>v</tt> in the vector <tt>x</tt>. If <tt>v</tt> is omitted, the functions expects a boolean vector as <tt>x</tt> and finds the first occurence of <tt>true</tt> </i>:</b>
$$funcref_description$$
  If both arguments are vectors, the occurence of every element in <tt>x</tt> is searched in <tt>v</tt>. If an elemnt is not found, the index -1 is returned.
  <!-- /func:findfirst -->  
$$funcref_end$$
  
  
  $$funcref_start$$<a name="alltrue"/><!-- func:alltrue -->
  <b><tt><!-- template -->alltrue(x)<!-- /template --></tt> - <i>returns <tt>true</tt> if all elements of the boolean vector <tt>x</tt> are <tt>true</tt> </i>:</b>
$$funcref_description$$
  <!-- /func:alltrue -->  
$$funcref_end$$   
  
  $$funcref_start$$<a name="allfalse"/><!-- func:allfalse -->
  <b><tt><!-- template -->allfalse(x)<!-- /template --></tt> - <i>returns <tt>true</tt> if all elements of the boolean vector <tt>x</tt> are <tt>false</tt> </i>:</b>
$$funcref_description$$
  <!-- /func:allfalse-->  
$$funcref_end$$
  
  $$funcref_start$$<a name="anytrue"/><!-- func:anytrue -->
  <b><tt><!-- template -->anytrue(x)<!-- /template --></tt> - <i>returns <tt>true</tt> if any element of the boolean vector <tt>x</tt> is <tt>true</tt> </i>:</b>
$$funcref_description$$
  <!-- /func:anytrue -->  
$$funcref_end$$   
  
  $$funcref_start$$<a name="anyfalse"/><!-- func:anyfalse -->
  <b><tt><!-- template -->anyfalse(x)<!-- /template --></tt> - <i>returns <tt>true</tt> if any element of the boolean vector <tt>x</tt> is <tt>false</tt> </i>:</b>
$$funcref_description$$
  <!-- /func:anyfalse-->  
$$funcref_end$$







<h2>Subvector Extraction &amp; Item Access</h2>
  $$funcref_start$$<a name="select"/><!-- func:select -->
  <b><tt><!-- template -->select(x, cond)<!-- /template --></tt> - <i>returns only those elements of a vector <tt>x</tt> where the boolean vector <tt>cond</tt> contains <tt>true</tt>. Both vectors have to have the same number of elements. </i>:</b>
$$funcref_description$$
  This function can be used to filter vectors according to a boolean expression, e.g. <tt>select(x, x>4)</tt> will return a vector containing only those elements in x where the value is larger than 4. This can also be implemented using <tt>x[<a href="#find">find</a>(x>4)]</tt>. So this function is a more expressive short-form for that. $$see:<a href="#findfirst">findfirst()</a>, <a href="#find">find()</a>$$
  <!-- /func:select -->  
$$funcref_end$$

  $$funcref_start$$<a name="first"/><!-- func:first -->
  <b><tt><!-- template -->first(x)<!-- /template --></tt> - <i>returns the first element in the vector <tt>x</tt>, or the first character of a string <tt>x</tt></i>:</b>
$$funcref_description$$
  <!-- /func:first-->  
$$funcref_end$$

  $$funcref_start$$<a name="last"/><!-- func:last -->
  <b><tt><!-- template -->last(x)<!-- /template --></tt> - <i>returns the last element in the vector <tt>x</tt>, or the last character of a string <tt>x</tt></i>:</b>
$$funcref_description$$
  <!-- /func:last-->  
$$funcref_end$$


  $$funcref_start$$<a name="firstinvector"/><!-- func:firstinvector -->
  <b><tt><!-- template -->firstinvector(x)<!-- /template --></tt> - <i>returns the first element in the vector <tt>x</tt></i>:</b>
$$funcref_description$$
  <!-- /func:firstinvector-->  
$$funcref_end$$

  $$funcref_start$$<a name="lastinvector"/><!-- func:lastinvector -->
  <b><tt><!-- template -->lastinvector(x)<!-- /template --></tt> - <i>returns the last element in the vector <tt>x</tt></i>:</b>
$$funcref_description$$
  <!-- /func:lastinvector-->  
$$funcref_end$$
  
  $$funcref_start$$<a name="item"/><!-- func:item -->
  <b><tt><!-- template -->item(x, idx)<!-- /template --></tt> - <i>If <tt>idx</tt>is an integer vector, this function returns the elements of vector <tt>x</tt> referenced by integer vector <tt>idx</tt></i>. If <tt>idx</tt>is vector of boolean, this function returns the elements of vector <tt>x</tt> where the according element in <tt>idx</tt> is <tt>true</tt></i>. The argument <tt>x</tt> may be a vector of numbers, boolean or strings, or a string. In the latter case the function accesses characters in the string.</b>
$$funcref_description$$
  $$example:<tt>item([1,2,3,4,5,6,7,8,9], [1,3,5])</tt> will return <tt>[2,4,6]</tt>$$
  $$example:<tt>item([1,2,3,4,5,6,7,8,9], [true,true,true,false,false,false,true,false,true])</tt> will return <tt>[1,2,3,7,9]</tt>$$
  $$example:<tt>item("abcdefghij", [1,3,5])</tt> will return <tt>"bdf"</tt>$$
  $$example:<tt>item("abcdefghi", [true,true,true,false,false,false,true,false,true])</tt> will return <tt>"abcgi"</tt>$$
  <!-- /func:item-->  
$$funcref_end$$

  $$funcref_start$$<a name="itemorfirst"/><!-- func:itemorfirst -->
  <b><tt><!-- template -->itemorfirst(x, idx)<!-- /template --></tt> - <i>If <tt>idx</tt>is an integer vector, this function returns the elements of vector <tt>x</tt> referenced by integer vector <tt>idx</tt></i>. If <tt>idx</tt>is vector of boolean, this function returns the elements of vector <tt>x</tt> where the according element in <tt>idx</tt> is <tt>true</tt></i>. The argument <tt>x</tt> may be a vector of numbers, boolean or strings, or a string. In the latter case the function accesses characters in the string. If the indexing does not work for any reason, the function returns <tt>x</tt>, or if <tt>x</tt> is a vector, its first element.</b>
$$funcref_description$$
  $$note:If the index access is valid, this function works the same as item(), except for strings: This function does not access single characters in the string!$$
  $$example:<tt>itemorfirst([1,2,3,4,5,6,7,8,9], [1,3,5])</tt> will return <tt>[2,4,6]</tt>$$
  $$example:<tt>itemorfirst([1,2,3,4,5,6,7,8,9], [true,true,true,false,false,false,true,false,true])</tt> will return <tt>[1,2,3,7,9]</tt>$$
  $$example:<tt>itemorfirst("abcdefghij", [1,3,5])</tt> will return <tt>"bdf"</tt>$$
  $$example:<tt>itemorfirst([1,2,3,4,5,6,7,8,9], -1)</tt> will return <tt></tt>$$
  $$example:<tt>itemorfirst([1,2,3,4,5,6,7,8,9], "bla")</tt> will return <tt></tt>$$
  <!-- /func:itemorfirst-->  
$$funcref_end$$





<h2>Ensure Vector Properties</h2>
  $$funcref_start$$<a name="ensuresize"/><!-- func:ensuresize -->
  <b><tt><!-- template -->ensuresize(x,desiredsize,defaultvalue)<!-- /template --></tt> - <i>returns the vector <tt>x</tt>, which is cut down, or elongated to length <tt>desiredsize</tt> </i>:</b>
$$funcref_description$$
  This function will remove elements from the end of the vector, or append elements of value <tt>defaultvalue</tt>.
  $$note:The datatype of <tt>defaultvalue</tt> has to be the type of an element of <tt>x</tt>! If <tt>x</tt> is a string, then <tt>defaultvalue</tt> has to contain a single character!$$
  $$example:<tt>ensuresize([1,2,3], 5, -1)</tt> will return <tt>[1,2,3,-1,-1]</tt>$$
  $$example:<tt>ensuresize("Hello", 8, "!")</tt> will return <tt>"Hello!!!"</tt>$$
  <!-- /func:ensuresize -->  
$$funcref_end$$
  $$funcref_start$$<a name="ensuresize_start"/><!-- func:ensuresize_start -->
  <b><tt><!-- template -->ensuresize_start(x,desiredsize,defaultvalue)<!-- /template --></tt> - <i>returns the vector <tt>x</tt>, which is cut down, or elongated to length <tt>desiredsize</tt> </i>:</b>
$$funcref_description$$
  This function will remove elements from the start of the vector, or prepend elements of value <tt>defaultvalue</tt>.
  $$note:The datatype of <tt>defaultvalue</tt> has to be the type of an element of <tt>x</tt>! If <tt>x</tt> is a string, then <tt>defaultvalue</tt> has to contain a single character!$$
  $$example:<tt>ensuresize_start([1,2,3], 5, -1)</tt> will return <tt>[-1,-1,1,2,3]</tt>$$
  $$example:<tt>ensuresize_start("Hello", 8, "!")</tt> will return <tt>"!!!Hello"</tt>$$
  <!-- /func:ensuresize_start -->  
$$funcref_end$$








<h2>Vector Properties</h2>
  $$funcref_start$$<a name="length"/><!-- func:length -->
  <b><tt><!-- template -->length(x)<!-- /template --></tt> - <i>returns the length of vector <tt>x</tt> </i>:</b>
$$funcref_description$$
  <!-- /func:length -->  
$$funcref_end$$

  
  $$funcref_start$$<a name="count"/><!-- func:count -->
  <b><tt><!-- template -->count(x[, value])<!-- /template --></tt> - <i>returns the number of elements in the vector <tt>x</tt> that have value <tt>value</tt> </i>:</b>
$$funcref_description$$
    If <tt>x</tt> is a number vector and no <tt>value</tt> is given, the function counts the number of good values (non-inf/nan/...) in <tt>x</tt>. <br>
	If <tt>x</tt> is a boolean vector and no <tt>value</tt> is given, the function counts the number of trues in <tt>x</tt>. 
  <!-- /func:count-->  
$$funcref_end$$







<h2>Mathematical Vector-Operations</h2>
  $$funcref_start$$<a name="dot"/><!-- func:dot -->
  <b><tt><!-- template -->dot(x,y)<!-- /template --></tt> - <i>returns the dot product of two numeric vectors <tt>x</tt> and  <tt>x</tt> </i>:</b>
$$funcref_description$$
  <!-- /func:dot -->  
$$funcref_end$$
     
  
   
  $$funcref_start$$<a name="runningaverage"/><!-- func:runningaverage -->
  <b><tt><!-- template -->runningaverage(x, width)<!-- /template --></tt> - <i>calculates the running average over vector <tt>x</tt> with width <tt>width</tt></i>. The argument <tt>x</tt> has to be a vector of numbers and <tt>width</tt> an integer >0</b>
$$funcref_description$$
  The functions averages <tt>width</tt> consecutive entries in <tt>x</tt>, if less than <tt>width</tt> entries remain in <tt>x</tt>, they are omitted.
  $$example:<tt>runningaverage([1,2,3,4,5,6,7,8,9], 3)</tt> will return <tt>[2,5,8]</tt>$$
  
  <!-- /func:runningaverage-->  
$$funcref_end$$

    
  
  
  
  </body>
  </html>
  