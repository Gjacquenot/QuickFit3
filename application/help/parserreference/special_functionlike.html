  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
  <html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=windows-1250">
  <title>Expression parser: Special Functions</title>
  </head>
  <body> 
  $$qf_commondoc_header.start$$  $$qf_commondoc_header.end$$ 
  
  
   
  
  <h2>Function-Like Constructs</h2>
  
    
  $$funcref_start$$<a name="if"/><!-- func:if -->
  <b><tt><!-- template -->if(c, t, f)<!-- /template --></tt> - <i>returns <tt>t</tt>, if <tt>c</tt> is true and <tt>f</tt> else. </i>:</b>
$$funcref_description$$ Only one of the expressions t and f are evaluated, depending on the value of c which is always evaluated
  <!-- /func:if -->  
$$funcref_end$$
  
  $$funcref_start$$<a name="cases"/><!-- func:cases -->
  <b><tt><!-- template -->cases(c1, t1, c2, t2, ..., else)<!-- /template --></tt> - <i>a cases statement, i.e. <code>if(c1, t1, if(c2, t2, if(..., else)))</code> </i>:</b>
$$funcref_description$$goes through the parameter list and first tests c1, if it is true the function returns t1, else it evaluates c2, if this is true, the function returns t2 ... If no condition evaluates to true, the function returns the value of else
  <!-- /func:cases -->  
$$funcref_end$$
    
  $$funcref_start$$<a name="for"/><!-- func:for -->
  <b><tt><!-- template -->for(VAR, start, delta, end, expression)<!-- /template --></tt>, <tt>for(VAR, start, end, expression)</tt> or <tt>for(VAR, value_vector, expression)</tt> - <i>returns a vector of <tt>expression</tt>, evaluated one time for every value in the vector/list <tt>value_vector</tt> or every value between <tt>start</tt> and <tt>end</tt> with step <tt>delta</tt> (default: 1). The variable <tt>VAR</tt> holds the according value in each iteration</i>:</b> 
$$funcref_description$$example: <code>for(i,1,2,5,i^2)</code> will return <code>[1^2, 3^2, 5^2]=[1,9,25]</code>
  <!-- /func:for -->  
$$funcref_end$$
   
  $$funcref_start$$<a name="defaultfor"/><!-- func:defaultfor -->
  <b><tt><!-- template -->defaultfor(VAR, start, delta, end, expression, default)<!-- /template --></tt>, <tt>defaultfor(VAR, start, end, expression, default)</tt> or <tt>defaultfor(VAR, value_vector, expression, default)</tt> - <i>returns a vector of <tt>expression</tt>, evaluated one time for every value in the vector/list <tt>value_vector</tt> or every value between <tt>start</tt> and <tt>end</tt> with step <tt>delta</tt> (default: 1). The variable <tt>VAR</tt> holds the according value in each iteration</i>. If <tt>expression</tt> evaluates to an incompatible type, <tt>, default</tt> is evaluated and the result added to the output vector:</b> 
$$funcref_description$$example: <code>defaultfor(i,1,5,if(i>3,"bla",i^2), -1)</code> will return <code>[1^2, 2^2, 3^2, -1, -1]=[1,9,25,-1,-1]</code>,<br>whereas <code>for(i,1,5,if(i>3,"bla",i^2))</code> will result in an error.
  <!-- /func:defaultfor -->  
$$funcref_end$$
     
  $$funcref_start$$<a name="savefor"/><!-- func:savefor -->
  <b><tt><!-- template -->savefor(VAR, start, delta, end, expression)<!-- /template --></tt>, <tt>savefor(VAR, start, end, expression)</tt> or <tt>savefor(VAR, value_vector, expression)</tt> - <i>returns a vector of <tt>expression</tt>, evaluated one time for every value in the vector/list <tt>value_vector</tt> or every value between <tt>start</tt> and <tt>end</tt> with step <tt>delta</tt> (default: 1). The variable <tt>VAR</tt> holds the according value in each iteration (save versioN!)</i>:</b> 
$$funcref_description$$example: <code>savefor(i,1,2,5,i^2)</code> will return <code>[1^2, 3^2, 5^2]=[1,9,25]</code>
  $$note:This is a save version of the command <tt>for(---)</tt>, if the expression does not evaluate to the expected type, it is simply ignored and no error is caused!$$
  <!-- /func:savefor -->  
$$funcref_end$$

  $$funcref_start$$<a name="filterfor"/><!-- func:filterfor -->
  <b><tt><!-- template -->filterfor(VAR, start, delta, end, expression)<!-- /template --></tt>, <tt>filterfor(VAR, start, end, expression)</tt> or <tt>filterfor(VAR, value_vector, expression)</tt> - <i>returns a vector with those elements in the vector/list <tt>value_vector</tt> or every value between <tt>start</tt> and <tt>end</tt> with step <tt>delta</tt> (default: 1), for which the <tt>expression</tt> evaluates to true. The variable <tt>VAR</tt> holds the according value in each iteration</i>:</b> 
$$funcref_description$$example: <code>filterfor(i,1,10,i&lt;4)</code> will return <code>[1,2,3]</code><br>
example: <code>filterfor(s, ["Hi Susy", "Hi Mark", "Bye Susy", "Bye Mark", "Hi Alonso"],contains(s, "Hi"))</code> will return <code>["Hi Susy", "Hi Mark", "Hi Alonso"]</code>
  <!-- /func:filterfor -->  
$$funcref_end$$
     


<h2>Sums, Products, ...</h2>
    
  $$funcref_start$$<a name="sum"/><!-- func:sum -->
  <b><tt><!-- template -->sum(VAR, start, delta, end, expression)<!-- /template --></tt>, <tt>sum(VAR, start, end, expression)</tt> or <tt>sum(VAR, value_vector, expression)</tt> or <tt>sum(data_vector)</tt> - <i>returns the sum of <tt>expression</tt>, evaluated one time for every value in the vector <tt>value_vector</tt> or every value between <tt>start</tt> and <tt>end</tt> with step <tt>delta</tt> (default: 1). The variable <tt>VAR</tt> holds the according value in each iteration</i>:</b> 
$$funcref_description$$example: <code>sum(i,1,2,5,i^2)</code> will return <code>1^2+3^2+5^2=35</code><br>If only one vector is given as parameter, the  sum of this vector is returned.
  <!-- /func:sum -->  
$$funcref_end$$
    
  $$funcref_start$$<a name="prod"/><!-- func:prod -->
  <b><tt><!-- template -->prod(VAR, start, delta, end, expression)<!-- /template --></tt>, <tt>prod(VAR, start, end, expression)</tt> or <tt>prod(VAR, value_vector, expression)</tt> or <tt>prod(data_vector)</tt> - <i>returns the product of <tt>expression</tt>, evaluated one time for every value in the vector <tt>value_vector</tt> or every value between <tt>start</tt> and <tt>end</tt> with step <tt>delta</tt> (default: 1). The variable <tt>VAR</tt> holds the according value in each iteration</i>:</b> 
$$funcref_description$$example: <code>prod(i,1,2,5,i^2)</code> will return <code>1^2*3^2*5^2=225</code><br>If only one vector is given as parameter, the  product of this vector is returned.
  <!-- /func:prod -->  
$$funcref_end$$
    
  $$funcref_start$$<a name="cumsum"/><!-- func:cumsum -->
  <b><tt><!-- template -->cumsum(VAR, start, delta, end, expression)<!-- /template --></tt>, <tt>cumsum(VAR, start, end, expression)</tt> or <tt>cumsum(VAR, value_vector, expression)</tt> or <tt>cumsum(data_vector)</tt> - <i>returns the cummulative sum of <tt>expression</tt>, evaluated one time for every value in the vector <tt>value_vector</tt> or every value between <tt>start</tt> and <tt>end</tt> with step <tt>delta</tt> (default: 1). The variable <tt>VAR</tt> holds the according value in each iteration</i>:</b>
$$funcref_description$$If only one vector is given as parameter, the cummulative sum of this vector is returned.
  <!-- /func:cumsum -->  
$$funcref_end$$
    
  $$funcref_start$$<a name="cumprod"/><!-- func:cumprod -->
  <b><tt><!-- template -->cumprod(VAR, start, delta, end, expression)<!-- /template --></tt>, <tt>cumprod(VAR, start, end, expression)</tt> or <tt>cumprod(VAR, value_vector, expression)</tt> or <tt>cumprod(data_vector)</tt> - <i>returns the product of <tt>expression</tt>, evaluated one time for every value in the vector <tt>value_vector</tt> or every value between <tt>start</tt> and <tt>end</tt> with step <tt>delta</tt> (default: 1). The variable <tt>VAR</tt> holds the according value in each iteration</i>:</b>
$$funcref_description$$If only one vector is given as parameter, the cummulative product of this vector is returned.
  <!-- /func:cumprod -->  
$$funcref_end$$


  

  
  
  </body>
  </html>
  