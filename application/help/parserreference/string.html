  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
  <html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=windows-1250">
  <title>Data Table Online-Help: Expression parser: String Functions</title>
  </head>
  <body> 
  $$qf_commondoc_header.start$$  $$qf_commondoc_header.end$$ 
  

  <h2>String Functions</h2>
  
  $$funcref_start$$<a name="int2str"/><!-- func:int2str -->
  <b><tt><!-- template -->int2str(x)<!-- /template --></tt> - <i>casts x to an ineteger and returns it as a string </i>:</b>
$$funcref_description$$
  <!-- /func:int2str -->  
$$funcref_end$$

  $$funcref_start$$<a name="int2bin"/><!-- func:int2bin -->
  <b><tt><!-- template -->int2bin(x)<!-- /template --></tt> - <i>casts x to an ineteger and returns it in binary representation as a string </i>:</b>
$$funcref_description$$
  <!-- /func:int2bin -->  
$$funcref_end$$
 
  $$funcref_start$$<a name="int2hex"/><!-- func:int2hex -->
  <b><tt><!-- template -->int2hex(x)<!-- /template --></tt> - <i>casts x to an ineteger and returns it in hexadecimal representation as a string </i>:</b>
$$funcref_description$$
  <!-- /func:int2hex -->  
$$funcref_end$$
 
  $$funcref_start$$<a name="int2oct"/><!-- func:int2oct -->
  <b><tt><!-- template -->int2oct(x)<!-- /template --></tt> - <i>casts x to an ineteger and returns it in octal representation as a string </i>:</b>
$$funcref_description$$
  <!-- /func:int2oct -->  
$$funcref_end$$
 
 
  $$funcref_start$$<a name="num2str"/><!-- func:num2str -->
  <b><tt><!-- template -->num2str(x)<!-- /template --></tt> - <i>returns the floating point number x as a string </i>:</b>
$$funcref_description$$
  <!-- /func:num2str -->  
$$funcref_end$$
  
  $$funcref_start$$<a name="bool2str"/><!-- func:bool2str -->
  <b><tt><!-- template -->bool2str(x)<!-- /template --></tt> - <i>returns the given boolean as a string </i>:</b>
$$funcref_description$$
  <!-- /func:bool2str -->  
$$funcref_end$$

  $$funcref_start$$<a name="str2num"/><!-- func:str2num -->
  <b><tt><!-- template -->str2num(x)<!-- /template --></tt> - <i>returns the floating point number represented by the string x (interprets a comma or a dot '.' as decimal separator) </i>:</b>
$$funcref_description$$
  <!-- /func:str2num -->  
$$funcref_end$$
  
  $$funcref_start$$<a name="cstr2num"/><!-- func:cstr2num -->
  <b><tt><!-- template -->cstr2num(x)<!-- /template --></tt> - <i>returns the floating point number represented by the string x (using C locale for conversion, i.e. only a dot '.' as decimal separator) </i>:</b>
$$funcref_description$$
  <!-- /func:cstr2num -->  
$$funcref_end$$
  
  $$funcref_start$$<a name="str2bool"/><!-- func:str2bool -->
  <b><tt><!-- template -->str2bool(x)<!-- /template --></tt> - <i>returns the boolean represented by the string x </i>:</b>
$$funcref_description$$
  <!-- /func:str2bool -->  
$$funcref_end$$
  

  $$funcref_start$$<a name="tosystempathseparator"/><!-- func:tosystempathseparator -->
  <b><tt><!-- template -->tosystempathseparator(x)<!-- /template --></tt> - <i>converts all backslashes and slashes in the given string x to the system standard directory separator (backslash on windows, slash on linux)</i>:</b>
$$funcref_description$$
  <!-- /func:tosystempathseparator -->  
$$funcref_end$$

  $$funcref_start$$<a name="tolower"/><!-- tolower:tolower -->
  <b><tt><!-- template -->tolower(x)<!-- /template --></tt> - <i>converts string to lower case</i>:</b>
$$funcref_description$$
  <!-- /func:tolower -->  
$$funcref_end$$

  $$funcref_start$$<a name="toupper"/><!-- tolower:toupper -->
  <b><tt><!-- template -->toupper(x)<!-- /template --></tt> - <i>converts string to upper case</i>:</b>
$$funcref_description$$
  <!-- /func:toupper -->  
$$funcref_end$$
  $$funcref_start$$<a name="trimm"/><!-- tolower:trimm -->
  <b><tt><!-- template -->trimm(x)<!-- /template --></tt> - <i>trimms leading and trailing whitespaces from the string</i>:</b>
$$funcref_description$$
  <!-- /func:trimm -->  
$$funcref_end$$

  
  
  <h2>Escapification</h2>
  $$funcref_start$$<a name="escapify"/><!-- func:escapify -->
    <b><tt><!-- template -->escapify(text)<!-- /template --></tt> - <i> convert the text to a text with C-escapes (\n \r ...) </i>:</b>
  $$funcref_description$$
        <!-- /func:escapify -->
  $$funcref_end$$
  
  $$funcref_start$$<a name="deescapify"/><!-- func:deescapify -->
    <b><tt><!-- template -->deescapify(text)<!-- /template --></tt> - <i> remove C-escapes (\n \r ...) from a string </i>:</b>
  $$funcref_description$$
        <!-- /func:deescapify -->
  $$funcref_end$$
  
  
  
  
  
  
  <h2>Regular Expressions Functions</h2>
  <p>This chapter groups QF math parser functions for regular expressions. Please see the <a href="../qf3_qtregexp.html">QuickFit regular expressions help page</a> for details on the supported set of regular expressions and their syntax.</p>
  
  
  $$funcref_start$$<a name="regexpcap"/><!-- func:regexpcap -->
  <b><tt><!-- template -->regexpcap(regexp, strings, cap_id=1, default_string="")<!-- /template --></tt> - <i>applies the given regular expression <tt>regexp</tt> to the given string or string vector in <tt>strings</tt>. The function returns the <tt>cap_id</tt>-th captured substring (the default is <tt>cap_id=1</tt>). This function uses non-minimal matching and is non-case-sensitive.</i>:</b>
$$funcref_description$$
  If the regular expression does not match, the given <tt>default_string</tt> is returned.
 
  <!-- /func:regexpcap -->  
$$funcref_end$$

  $$funcref_start$$<a name="regexpcontains"/><!-- func:regexpcontains -->
  <b><tt><!-- template -->regexpcontains(regexp, strings)<!-- /template --></tt> - <i>returns <tt>true</tt>, if the given regular expression <tt>regexp</tt> is present in the given string or string vector (item-wise for string vectors, i.e. returns a boolean vector) in <tt>strings</tt>. This function uses non-minimal matching and is non-case-sensitive.</i>:</b>
$$funcref_description$$
  <!-- /func:regexpcontains -->  
$$funcref_end$$
  $$funcref_start$$<a name="regexpindexin"/><!-- func:regexpindexin -->
  <b><tt><!-- template -->regexpindexin(regexp, strings)<!-- /template --></tt> - <i>returns index of the first occurence (or -1), of the given regular expression <tt>regexp</tt> in the given string or string vector (item-wise for string vectors, i.e. returns a number vector) in <tt>strings</tt>. This function uses non-minimal matching and is non-case-sensitive.</i>:</b>
$$funcref_description$$
  <!-- /func:regexpindexin -->  
$$funcref_end$$

  
    $$funcref_start$$<a name="regexpcap_minimal"/><!-- func:regexpcap_minimal -->
  <b><tt><!-- template -->regexpcap_minimal(regexp, strings, cap_id=1, default_string="")<!-- /template --></tt> - <i>applies the given regular expression <tt>regexp</tt> to the given string or string vector in <tt>strings</tt>. The function returns the <tt>cap_id</tt>-th captured substring (the default is <tt>cap_id=1</tt>). This function uses minimal matching and is non-case-sensitive.</i>:</b>
$$funcref_description$$
  If the regular expression does not match, the given <tt>default_string</tt> is returned.
 
  <!-- /func:regexpcap_minimal -->  
$$funcref_end$$

  $$funcref_start$$<a name="regexpcontains_minimal"/><!-- func:regexpcontains_minimal -->
  <b><tt><!-- template -->regexpcontains_minimal(regexp, strings)<!-- /template --></tt> - <i>returns <tt>true</tt>, if the given regular expression <tt>regexp</tt> is present in the given string or string vector (item-wise for string vectors, i.e. returns a boolean vector) in <tt>strings</tt>. This function uses minimal matching and is non-case-sensitive.</i>:</b>
$$funcref_description$$
  <!-- /func:regexpcontains_minimal -->  
$$funcref_end$$
  $$funcref_start$$<a name="regexpindexin_minimal"/><!-- func:regexpindexin_minimal -->
  <b><tt><!-- template -->regexpindexin_minimal(regexp, strings)<!-- /template --></tt> - <i>returns index of the first occurence (or -1), of the given regular expression <tt>regexp</tt> in the given string or string vector (item-wise for string vectors, i.e. returns a number vector) in <tt>strings</tt>. This function uses minimal matching and is non-case-sensitive.</i>:</b>
$$funcref_description$$
  <!-- /func:regexpindexin_minimal -->  
$$funcref_end$$
  
  
  
  
  
  
  
  
  
  $$funcref_start$$<a name="regexpcap_cs"/><!-- func:regexpcap_cs -->
  <b><tt><!-- template -->regexpcap_cs(regexp, strings, cap_id=1, default_string="")<!-- /template --></tt> - <i>applies the given regular expression <tt>regexp</tt> to the given string or string vector in <tt>strings</tt>. The function returns the <tt>cap_id</tt>-th captured substring (the default is <tt>cap_id=1</tt>). This function uses non-minimal matching and is case-sensitive.</i>:</b>
$$funcref_description$$
  If the regular expression does not match, the given <tt>default_string</tt> is returned.
 
  <!-- /func:regexpcap_cs -->  
$$funcref_end$$

  $$funcref_start$$<a name="regexpcontains_cs"/><!-- func:regexpcontains_cs -->
  <b><tt><!-- template -->regexpcontains_cs(regexp, strings)<!-- /template --></tt> - <i>returns <tt>true</tt>, if the given regular expression <tt>regexp</tt> is present in the given string or string vector (item-wise for string vectors, i.e. returns a boolean vector) in <tt>strings</tt>. This function uses non-minimal matching and is case-sensitive.</i>:</b>
$$funcref_description$$
  <!-- /func:regexpcontains_cs -->  
$$funcref_end$$
  $$funcref_start$$<a name="regexpindexin_cs"/><!-- func:regexpindexin_cs -->
  <b><tt><!-- template -->regexpindexin_cs(regexp, strings)<!-- /template --></tt> - <i>returns index of the first occurence (or -1), of the given regular expression <tt>regexp</tt> in the given string or string vector (item-wise for string vectors, i.e. returns a number vector) in <tt>strings</tt>. This function uses non-minimal matching and is case-sensitive.</i>:</b>
$$funcref_description$$
  <!-- /func:regexpindexin_cs -->  
$$funcref_end$$

  
    $$funcref_start$$<a name="regexpcap_cs_minimal"/><!-- func:regexpcap_cs_minimal -->
  <b><tt><!-- template -->regexpcap_cs_minimal(regexp, strings, cap_id=1, default_string="")<!-- /template --></tt> - <i>applies the given regular expression <tt>regexp</tt> to the given string or string vector in <tt>strings</tt>. The function returns the <tt>cap_id</tt>-th captured substring (the default is <tt>cap_id=1</tt>). This function uses minimal matching and is case-sensitive.</i>:</b>
$$funcref_description$$
  If the regular expression does not match, the given <tt>default_string</tt> is returned.
 
  <!-- /func:regexpcap_cs_minimal -->  
$$funcref_end$$

  $$funcref_start$$<a name="regexpcontains_cs_minimal"/><!-- func:regexpcontains_cs_minimal -->
  <b><tt><!-- template -->regexpcontains_cs_minimal(regexp, strings)<!-- /template --></tt> - <i>returns <tt>true</tt>, if the given regular expression <tt>regexp</tt> is present in the given string or string vector (item-wise for string vectors, i.e. returns a boolean vector) in <tt>strings</tt>. This function uses minimal matching and is case-sensitive.</i>:</b>
$$funcref_description$$
  <!-- /func:regexpcontains_cs_minimal -->  
$$funcref_end$$
  $$funcref_start$$<a name="regexpindexin_cs_minimal"/><!-- func:regexpindexin_cs_minimal -->
  <b><tt><!-- template -->regexpindexin_cs_minimal(regexp, strings)<!-- /template --></tt> - <i>returns index of the first occurence (or -1), of the given regular expression <tt>regexp</tt> in the given string or string vector (item-wise for string vectors, i.e. returns a number vector) in <tt>strings</tt>. This function uses minimal matching and is case-sensitive.</i>:</b>
$$funcref_description$$
  <!-- /func:regexpindexin_cs_minimal -->  
$$funcref_end$$

  
  </body>
  </html>
  