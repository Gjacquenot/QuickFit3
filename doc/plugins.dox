/*!
    \defgroup qf3plugins Plugins
    \ingroup quickfit3

    \defgroup qf3rawdataplugins Raw Data Record Plugins
    \ingroup qf3plugins

    \defgroup qf3evaluationplugins Evaluation Plugins
    \ingroup qf3plugins

    \defgroup qf3fitalgplugins Fitting Algorithm Plugins
    \ingroup qf3plugins

    \defgroup qf3fitfunplugins Fitting Function Plugins
    \ingroup qf3plugins

    \defgroup qf3extensionplugins QuickFit Extension Plugins
    \ingroup qf3plugins

    \defgroup qf3plugintools Plugin programming Tools
    \ingroup qf3plugins
*/

/*! \page plugins Writing Plugins
    \ingroup qf3plugins

    QuickFit 3 is in itself not a fitting application (as the name may suggest), but more or less just a
    data manager (see \link qf3app QuickFit Application \endlink ). The datatypes managed by QuickFit together
    with a variety of other features (like fit algorithms and functions, as well as data evaluations) are
    implemented by plugins.

    QuickFit uses the <a href="http://doc.qt.nokia.com/4.6/plugins-howto.html">Qt plugin lower-level API</a>
    to implement the different extensions, mentioned above. You will find more details about implementing plugins
    here:
      - \link pluginsrdr Writing QFRawDataRecord Plugins \endlink
      - \link pluginseval Writing QFEvaluationItem Plugins \endlink
      - \link pluginsfitalg Writing Fit Algorithm Plugins \endlink
      - \link pluginsfitfunc Writing Fit Functions Plugins \endlink
      - \link pluginsextensions Writing QFExtension Plugins \endlink
    .
*/

/*! \page pluginsrdr Writing QFRawDataRecord Plugins
    \ingroup qf3plugins

    When implementing a new type of raw data record, you will have to follow these steps:
      - create a new Qt plugin project
      - implement a descendent of QFRawDataRecord which implements the desired features. This
        also includes implementing an editor for the data class!
      - implement a plugin class, derived from QFPluginRawDataRecordBase which describes
        the plugin (name, ID, ...) and provides methods that allow to register hooks used to create
        new objects (menu entries ...). Export this class in the plugin.
    .

    QuickFit 3 provides a menu that allows to add new data objects. The plugin class provides
    a register method that allows to add new entries/submenus to this menu. When doing so, you
    can hook those entries to methods in the plugin class that load data files, ...
*/


/*! \page pluginseval Writing QFEvaluationItem Plugins
    \ingroup qf3plugins


    When implementing a new type of evaluation, you will have to follow these steps:
      - create a new Qt plugin project
      - implement a descendent of QFEvaluationItem which implements the parameter storage for the
        evaluation. Also the logic of the evaluation may be implemented here. You should only store
        the global parameters here, as evaluation results that apply to only single files may be stored
        using the \c results*() functions of QFRawDataRecord together with the raw data.
      - implement a plugin class, derived from QFPluginEvaluationItemBase which describes
        the plugin (name, ID, ...) and provides methods that allow to register hooks used to create
        new objects (menu entries ...). Export this class in the plugin.
    .

    QuickFit 3 provides a menu that allows to add new data objects. The plugin class provides
    a register method that allows to add new entries/submenus to this menu. When doing so, you
    can hook those entries to methods in the plugin class that load data files, ...

*/

/*! \page pluginsfitalg Writing Fit Algorithm Plugins
    \ingroup qf3plugins


    Fit Algorithm plugins are somewhat simpler than \link pluginseval evaluation plugins \endlink and
    \link pluginsrdr raw data plugins \endlink . They consist only of one (or more) QFFitAlgorithm
    descendents which implements the fit algorithm as an optimization problem
      \f[ \vec{p}^\ast=\min\limits_{\vec{p}}\|\vec{f}(\vec{p})\| \f]
    in a single function QFFitAlgorithm::intFit(). In addition some  plugin description  methdos, like
    QFFitAlgorithm::name(), QFFitAlgorithm::id(), ... are implemented.

    For a detailed description of the possibilities of implementation, see the QFFitAlgorithm documentation.

    The Qt Plugin is implemented using the interface QFPluginFitAlgorithm. It is possible to implement
    different fitting algorithms in one plugin. Then you have to implement each algorithm in a separate
    QFFitAlgorithm plugin and return in QFPluginFitAlgorithm::getIDs() an ID for every algorithm. The method
    QFPluginFitAlgorithm::get() then returns an instance of the QFFitAlgorithm for a given id.

*/

/*! \page pluginsfitfunc Writing Fit Function Plugins
    \ingroup qf3plugins

    This class of plugins are fit functions designed to work together with QFFitAlgorithm fit routines.

    Fit Functions plugins are somewhat simpler than \link pluginseval evaluation plugins \endlink and
    \link pluginsrdr raw data plugins \endlink . They consist only of one (or more) QFFitFunction
    descendents which implements the fit function, possibly together with an implementation of analytical
    derivatives of the fucntion. In addition some plugin description  methdos, like QFFitFunction::name(),
    QFFitFunction::id(), ... are implemented.

    For a detailed description of the possibilities of implementation, see the QFFitFunction documentation.

    The Qt Plugin is implemented using the interface QFPluginFitFunction. It is possible to implement
    different fitting algorithms in one plugin. Then you have to implement each function in a separate
    QFFitFunction plugin and return in QFPluginFitFunction::getIDs() an ID for every function. The method
    QFPluginFitFunction::get() then returns an instance of the QFFitAlgorithm for a given id.

*/

/*! \page pluginsextensions Writing QFExtension Plugins
    \ingroup qf3plugins

    These plugins allow to write a wide variety of extensions to QuickFit 3. They are NOT used as part of the
    project tree, but extend the application directly. You may use them to use QuickFit as basis for Experiment
    control systems. As QFExtension plugins are informed about the current project, you my use them to alter the
    project or store data in it.

    If you want to write such plugins, you simply have to implement the interface QFExtension. Better derive your
    plugin from QFExtensionBase, as this already implements some functionality.

    Of each extension QuickFit creates one instance which is stored internally. After loading the plugin the instance
    is initialized using QFExtension::init() (if you want to react to it overload QFExtensionBase::initExtension() ).
    When the plugin is unloaded QFExtension::deinit() is called. You may use QFExtension::init() to register the
    extension to menus and toolbars (using QFExtensionServices). In addition the plugin is informed about every
    change of the current project (QFProject). In that case QuickFit calls QFExtension::setProject() (when reacting
    to this, overload QFExtensionBase::projectChanged(), or simply access QFExtensionBase::project).

    After QFExtension::init() has been called you my access the QFExtensionServices at every time, using
    QFExtensionBase::services. This may also be used to interface all other QFExtension s, currently loaded.
	
	
	\include plugin_template_projects/QFExtensionCamera/qfextensioncamera.cpp
*/
