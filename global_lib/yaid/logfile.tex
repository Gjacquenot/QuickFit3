\documentclass[a4paper,11pt]{article}


\begin{document}
%
\section{Roadmap}
%
\paragraph{Serialization}
Binary reading and writing of all data types with proper conversion from and to bid endianness, respectively.
%
\paragraph{Data manipulation}
Unified methods to manipulate data fields of different types in the Slice class.


%
%
\section{Logfile}
%
%
\paragraph{10.06.2001:}
\begin{itemize}
%
\item{Wrote small helper programm, endianness\_test, 
to test machine endianness during make process. The programm produces a header
file called endianness.hpp which is then included by serialization.hpp}
%
\item{Wrote some template classes in serialization.hpp that read and write data types with proper conversion between
big endianness, as required by the YAID format, and the machine own endianness. The templates use the numbers defined
in endianness.hpp  -- needs testing}
%
\item{Adjusted Makefile to properly compile and call endianness\_test}
%
\item{Implemented data reading (except for float and double types) in the Slice class}
%
\end{itemize}
%
%
\paragraph{14.06.2011}
%
\begin{itemize}
%
\item{Created this file}
%
\item{added 'ull' to some 64 bit numbers for compatibility with Windows compilor}
%
\item{added support to read data fields in Slice taking care of endianness swap where necessary -- needs testing}
%
\item{corrected options for 'ar' command in Makefile to replace rather than add changes to avoid linker errors}
%
\item{added basic support to manipulate data fields in Slice objects -- not yet ready}
\end{itemize}
%
%
\paragraph{15.06.2011}
%
\begin{itemize}
%
\item{Added a function to the Slice class that passes directly an address to the Data field for faster manipulation}
%
\item{Bound the new read() and write() functions of the FileReaderBinary and FileWriterBinary classes, respectively, to
the corresponding streaming operators, thus removing the run-time tests that have been formerly used in these operators}
%
\end{itemize}
%
%
\paragraph{16.06.2011}
%
\begin{itemize}
%
\item{Wrote pixel manipulation functions that take both the input type and the underlying data type into account. The
input type is templated, the data type is taken care of with pointer-to-member functions very much in the same way as
the data reading and writing functions.}
%
\item{Increased version number to 0.2}
%
\end{itemize}
%
\end{document}
