  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
  <html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=windows-1250">
  <title>Expression parser: GSL special functions</title>
  </head>
  <body> 
  $$qf_commondoc_header.start$$  $$qf_commondoc_header.end$$ 
  
  
  <ul>
	  <li><a name="hydrogenicR1"/><!-- func:hydrogenicR1 -->
	  <b><tt><!-- template -->hydrogenicR1(r,Z)<!-- /template --></tt> - <i> compute the lowest-order normalized hydrogenic bound state radial wavefunction $$math:R_1 := 2Z \sqrt{Z} \exp(-Z r)$$. </i></b><br>
	  <!-- /func:hydrogenicR1 -->
	  </li>

	  <li><a name="hydrogenicR"/><!-- func:hydrogenicR -->
	  <b><tt><!-- template -->hydrogenicR(r,n, l, Z)<!-- /template --></tt> - <i> compute the n-th normalized hydrogenic bound state radial wavefunction,$$bmath:R_n := 2 (Z^{3/2}/n^2) \sqrt{(n-l-1)!/(n+l)!} \exp(-Z r/n) (2Zr/n)^l L^{2l+1}_{n-l-1}(2Zr/n)$$.  where $$math:L^a_b(x)$$ is the generalized Laguerre polynomial. The normalization is chosen such that the wavefunction $$math:\psi$$ is given by $$math:\psi(n,l,r) = R_n Y_{lm}$$. </i></b><br>
	  <!-- /func:hydrogenicR -->
	  </li>

	  <li><a name="debye1"/><!-- func:debye1 -->
	  <b><tt><!-- template -->debye1(x)<!-- /template --></tt> - <i>compute the first-order Debye function $$math:D_1(x) = (1/x) \int_0^x dt (t/(e^t - 1))$$. </i></b><br>
	  <!-- /func:debye1 -->
	  </li>

	  <li><a name="debye2"/><!-- func:debye2 -->
	  <b><tt><!-- template -->debye2(x)<!-- /template --></tt> - <i>compute the second-order Debye function $$math: D_2(x) = (2/x^2) \int_0^x dt (t^2/(e^t - 1))$$. </i></b><br>
	  <!-- /func:debye2 -->
	  </li>

	  <li><a name="debye3"/><!-- func:debye3 -->
	  <b><tt><!-- template -->debye3(x)<!-- /template --></tt> - <i>compute the third-order Debye function $$math:D_3(x) = (3/x^3) \int_0^x dt (t^3/(e^t - 1))$$. </i></b><br>
	  <!-- /func:debye3 -->
	  </li>

	  <li><a name="debye4"/><!-- func:debye4 -->
	  <b><tt><!-- template -->debye4(x)<!-- /template --></tt> - <i>compute the fourth-order Debye function $$math:D_4(x) = (4/x^4) \int_0^x dt (t^4/(e^t - 1))$$. </i></b><br>
	  <!-- /func:debye4 -->
	  </li>

	  <li><a name="debye5"/><!-- func:debye5 -->
	  <b><tt><!-- template -->debye5(x)<!-- /template --></tt> - <i>compute the fifth-order Debye function $$math:D_5(x) = (5/x^5) \int_0^x dt (t^5/(e^t - 1))$$. </i></b><br>
	  <!-- /func:debye5 -->
	  </li>

	  <li><a name="debye6"/><!-- func:debye6 -->
	  <b><tt><!-- template -->debye6(x)<!-- /template --></tt> - <i>compute the sixth-order Debye function $$math:D_6(x) = (6/x^6) \int_0^x dt (t^6/(e^t - 1))$$. </i></b><br>
	  <!-- /func:debye6 -->
	  </li>

	  <li><a name="dilog"/><!-- func:dilog -->
	  <b><tt><!-- template -->dilog(x)<!-- /template --></tt> - <i>compute the dilogarithm for a real argument. In Lewin’s notation this is $$math:Li_2(x)$$, the real part of the dilogarithm of a real x. It is defined by the integral representation $$math:Li_2(x) = - \Re \int_0^x ds \log(1-s) / s$$. Note that $$math:\Im(Li_2(x)) = 0 for x <= 1$$, and $$math:-\pi\log(x) for x > 1$$.
	 </i></b><br>
	 Note that Abramowitz & Stegun refer to the Spence integral $$math:S(x)=Li_2(1-x)$$ as the dilogarithm rather than $$math:Li_2(x)$$.
	  <!-- /func:dilog -->
	  </li>

	  <li><a name="fact"/><!-- func:fact -->
	  <b><tt><!-- template -->fact(n)<!-- /template --></tt> - <i>compute the factorial n!. The factorial is related to the Gamma function by $$math:n! = \Gamma(n+1)$$. The maximum value of n such that n! is not considered an overflow is 170. </i></b><br>
	  <!-- /func:fact -->
	  </li>

	  <li><a name="doublefact"/><!-- func:doublefact -->
	  <b><tt><!-- template -->doublefact(n)<!-- /template --></tt> - <i>compute the double factorial $$math:n!! = n(n-2)(n-4) \dots$$. The maximum value of n such that n!! is not considered an overflow is 297</i></b><br>
	  <!-- /func:doublefact -->
	  </li>

	  	  <li><a name="lnfact"/><!-- func:lnfact -->
	  <b><tt><!-- template -->lnfact(n)<!-- /template --></tt> - <i>compute the logarithm of the factorial of n, $$math:\log(n!)$$. The algorithm is faster than computing $$math:\ln(\Gamma(n+1))$$ via gsl_sf_lngamma for n < 170, but defers for larger n</i></b><br>
	  <!-- /func:lnfact -->
	  </li>

	  <li><a name="lndoublefact"/><!-- func:lndoublefact -->
	  <b><tt><!-- template -->lndoublefact(n)<!-- /template --></tt> - <i>compute the logarithm of the double factorial of n, $$math:\log(n!!)$$. </i></b><br>
	  <!-- /func:lndoublefact -->
	  </li>

	  
	  <li><a name="choose"/><!-- func:choose -->
	  <b><tt><!-- template -->choose(n, m)<!-- /template --></tt> - <i>compute the combinatorial factor <tt>n choose m = n!/(m!(n-m)!)</tt></i></b><br>
	  <!-- /func:choose -->
	  </li>

	  <li><a name="lnchoose"/><!-- func:lnchoose -->
	  <b><tt><!-- template -->lnchoose(n, m)<!-- /template --></tt> - <i>compute the logarithm of n choose m. This is equivalent to the sum $$math:\log(n!) - \log(m!) - \log((n-m)!)$$. </i></b><br>
	  <!-- /func:lnchoose -->
	  </li>

	  <li><a name="taylorcoeff "/><!-- func:taylorcoeff  -->
	  <b><tt><!-- template -->taylorcoeff(x,n)<!-- /template --></tt> - <i>compute the Taylor coefficient $$math:x^n / n!$$ for $$math:x >= 0, n >= 0$$. </i></b><br>
	  <!-- /func:taylorcoeff  -->
	  </li>
	  <li><a name="gamma"/><!-- func:gamma -->
	  <b><tt><!-- template -->gamma(x)<!-- /template --></tt> - <i>compute the Gamma function $$math:\Gamma(x)$$, subject to x not being a negative integer or zero. The function is computed using the real Lanczos method. The maximum value of x such that $$math:\Gamma(x)$$ is not considered an overflow is 171.0. </i></b><br>
	  $$bmath:\Gamma(x) = \int_0^\infty dt  t^{x-1} \exp(-t)$$
	  <!-- /func:gamma -->
	  </li>
	  	  <li><a name="lngamma"/><!-- func:lngamma -->
	  <b><tt><!-- template -->lngamma(x)<!-- /template --></tt> - <i>These routines compute the logarithm of the Gamma function, $$math:\log(\Gamma(x))$$, subject to x not being a negative integer or zero. For x<0 the real part of $$math:\log(\Gamma(x))$$ is returned, which is equivalent to $$math:\log(|\Gamma(x)|)$$. The function is computed using the real Lanczos method.  </i></b><br>
	  $$bmath:\Gamma(x) = \int_0^\infty dt  t^{x-1} \exp(-t)$$
	  <!-- /func:lngamma -->
	  </li>
	  <li><a name="beta"/><!-- func:beta -->
	  <b><tt><!-- template -->beta(a,b)<!-- /template --></tt> - <i>compute the Beta Function, $$math:B(a,b) = \Gamma(a)\Gamma(b)/\Gamma(a+b)$$ subject to a and b not being negative integers. </i></b><br>
	  $$bmath:\Gamma(x) = \int_0^\infty dt  t^{x-1} \exp(-t)$$
	  <!-- /func:beta -->
	  </li>	  
	  <li><a name="lnbeta"/><!-- func:lnbeta -->
	  <b><tt><!-- template -->lnbeta(a,b)<!-- /template --></tt> - <i>compute the logarithm of the Beta Function, $$math:\log(B(a,b)) = \log(\Gamma(a)\Gamma(b)/\Gamma(a+b))$$ subject to a and b not being negative integers. </i></b><br>
	  $$bmath:\Gamma(x) = \int_0^\infty dt  t^{x-1} \exp(-t)$$
	  <!-- /func:lnbeta -->
	  </li>
	  <li><a name="laguerre1"/><!-- func:laguerre1 -->
	  <b><tt><!-- template -->laguerre1(x,a)<!-- /template --></tt> - <i>These routines evaluate the generalized Laguerre polynomials $$math:L^a_1(x)$$ using explicit representations. </i></b><br>
	  The generalized Laguerre polynomials are defined in terms of confluent hypergeometric functions as $$math:L^a_n(x) = ((a+1)_n / n!) 1F1(-n,a+1,x)$$, and are sometimes referred to as the associated Laguerre polynomials. They are related to the plain Laguerre polynomials $$math:L_n(x)$$ by $$math:L^0_n(x) = L_n(x)$$ and $$math:L^k_n(x) = (-1)^k (d^k/dx^k) L_(n+k)(x)$$. For more information see Abramowitz & Stegun, Chapter 22. 
	  <!-- /func:laguerre1 -->
	  </li>
	  <li><a name="laguerre2"/><!-- func:laguerre2 -->
	  <b><tt><!-- template -->laguerre2(x,a)<!-- /template --></tt> - <i>These routines evaluate the generalized Laguerre polynomials $$math:L^a_2(x)$$ using explicit representations. </i></b><br>
	  The generalized Laguerre polynomials are defined in terms of confluent hypergeometric functions as $$math:L^a_n(x) = ((a+1)_n / n!) 1F1(-n,a+1,x)$$, and are sometimes referred to as the associated Laguerre polynomials. They are related to the plain Laguerre polynomials $$math:L_n(x)$$ by $$math:L^0_n(x) = L_n(x)$$ and $$math:L^k_n(x) = (-1)^k (d^k/dx^k) L_(n+k)(x)$$. For more information see Abramowitz & Stegun, Chapter 22. 
	  <!-- /func:laguerre2 -->
	  </li>
	  <li><a name="laguerre3"/><!-- func:laguerre3 -->
	  <b><tt><!-- template -->laguerre3(x,a)<!-- /template --></tt> - <i>These routines evaluate the generalized Laguerre polynomials $$math:L^a_3(x)$$ using explicit representations. </i></b><br>
	  The generalized Laguerre polynomials are defined in terms of confluent hypergeometric functions as $$math:L^a_n(x) = ((a+1)_n / n!) 1F1(-n,a+1,x)$$, and are sometimes referred to as the associated Laguerre polynomials. They are related to the plain Laguerre polynomials $$math:L_n(x)$$ by $$math:L^0_n(x) = L_n(x)$$ and $$math:L^k_n(x) = (-1)^k (d^k/dx^k) L_(n+k)(x)$$. For more information see Abramowitz & Stegun, Chapter 22. 
	  <!-- /func:laguerre3 -->
	  </li>
	  <li><a name="laguerre"/><!-- func:laguerre -->
	  <b><tt><!-- template -->laguerre(x,a,n)<!-- /template --></tt> - <i>evaluate the generalized Laguerre polynomials $$math:L^a_n(x)$$ for a > -1, n >= 0.</i></b><br>
	  The generalized Laguerre polynomials are defined in terms of confluent hypergeometric functions as $$math:L^a_n(x) = ((a+1)_n / n!) 1F1(-n,a+1,x)$$, and are sometimes referred to as the associated Laguerre polynomials. They are related to the plain Laguerre polynomials $$math:L_n(x)$$ by $$math:L^0_n(x) = L_n(x)$$ and $$math:L^k_n(x) = (-1)^k (d^k/dx^k) L_(n+k)(x)$$. For more information see Abramowitz & Stegun, Chapter 22. 
	  <!-- /func:laguerre -->
	  </li>
	  <li><a name="angle_restrict_symm"/><!-- func:angle_restrict_symm -->
	  <b><tt><!-- template -->angle_restrict_symm(theta)<!-- /template --></tt> - <i>force the angle theta to lie in the range $$math:(-\pi,\pi]$$.</i></b><br>
	  <!-- /func:angle_restrict_symm -->
	  </li>
	  <li><a name="angle_restrict_pos"/><!-- func:angle_restrict_pos -->
	  <b><tt><!-- template -->angle_restrict_pos(theta)<!-- /template --></tt> - <i>force the angle theta to lie in the range $$math:[0, 2\pi)$$. </i></b><br>
	  <!-- /func:angle_restrict_pos -->
	  </li>
	  

  </ul>
  
  </body>
  </html>
  